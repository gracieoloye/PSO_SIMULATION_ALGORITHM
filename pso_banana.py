# -*- coding: utf-8 -*-
"""PSO_Banana

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1SWMXoNyTygQGagUttBju-kXzVlkDw8pR

# PSO IMPLEMENTATION: ROSENBROCK (BANANA) FUNCTION

## 1. Configuration
"""

import numpy as np
import matplotlib.pyplot as plt
from matplotlib.animation import FuncAnimation
from IPython.display import display, HTML, clear_output

FUNCTION_NAME = "Rosenbrock (Banana)"
BOUNDS = [-2, 2]
PARTICLES = 50
ITERATIONS = 50
# Adaptive Inertia Parameters
W_MAX = 0.9
W_Min = 0.4
C1 = 1.4 # Cognitive
C2 = 1.4 # Social

"""## 2. The Objective Function





![image.png](data:image/png;base64,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)
"""

def banana_function(x, y):
    # Global Minimum at (1, 1)
    a = 1
    b = 100
    return (a - x)**2 + b * (y - x**2)**2

"""## 3. Initialization"""

print(f"Initializing {FUNCTION_NAME} Optimization...")
# Random positions and velocities
px = np.random.uniform(BOUNDS[0], BOUNDS[1], PARTICLES)
py = np.random.uniform(BOUNDS[0], BOUNDS[1], PARTICLES)
vx = np.random.uniform(-1, 1, PARTICLES)
vy = np.random.uniform(-1, 1, PARTICLES)

# Initialize Memory
pbest_x = px.copy()
pbest_y = py.copy()
pbest_val = banana_function(px, py)

# Find initial Global Best
min_idx = np.argmin(pbest_val)
gbest_x = pbest_x[min_idx]
gbest_y = pbest_y[min_idx]
gbest_val = pbest_val[min_idx]

# History lists for plotting/video
history_pos = []
convergence_curve = []

"""## 4. Optimization Loop (with Adaptive Inertia)"""

for i in range(ITERATIONS):
    # Record history
    history_pos.append(np.column_stack((px, py)))
    convergence_curve.append(gbest_val)

    # A. Calculate Adaptive Inertia (Linearly Decreasing)
    w = W_MAX - ((W_MAX - W_Min) * i / ITERATIONS)

    # B. Update Velocity
    r1 = np.random.rand(PARTICLES)
    r2 = np.random.rand(PARTICLES)

    vx = (w * vx) + (C1 * r1 * (pbest_x - px)) + (C2 * r2 * (gbest_x - px))
    vy = (w * vy) + (C1 * r1 * (pbest_y - py)) + (C2 * r2 * (gbest_y - py))

    # C. Update Position
    px = px + vx
    py = py + vy
    # Clip to bounds
    px = np.clip(px, BOUNDS[0], BOUNDS[1])
    py = np.clip(py, BOUNDS[0], BOUNDS[1])

    # D. Evaluation
    current_val = banana_function(px, py)

    # E. Update Personal Best
    better_mask = current_val < pbest_val
    pbest_x[better_mask] = px[better_mask]
    pbest_y[better_mask] = py[better_mask]
    pbest_val[better_mask] = current_val[better_mask]

    # F. Update Global Best
    min_idx = np.argmin(pbest_val)
    if pbest_val[min_idx] < gbest_val:
        gbest_val = pbest_val[min_idx]
        gbest_x = pbest_x[min_idx]
        gbest_y = pbest_y[min_idx]

print(f"Optimization Complete. Best Value: {gbest_val:.6f} at ({gbest_x:.4f}, {gbest_y:.4f})")

"""## 5. Report Visualsation"""

# Plot 1: Convergence Curve (Evidence of Intelligence)
plt.figure(figsize=(8, 4))
plt.plot(convergence_curve, label='Best Cost')
plt.yscale('log') # Log scale highlights convergence better
plt.title(f'Convergence Curve: {FUNCTION_NAME}')
plt.xlabel('Iteration')
plt.ylabel('Cost (Log Scale)')
plt.grid(True, which="both", ls="-", alpha=0.2)
plt.legend()
plt.savefig('banana_convergence.png')
print("Saved 'banana_convergence.png'")
plt.show()

# Plot 2: Video Animation
fig, ax = plt.subplots(figsize=(6, 6))
# Background Contour
x_grid = np.linspace(BOUNDS[0], BOUNDS[1], 100)
y_grid = np.linspace(BOUNDS[0], BOUNDS[1], 100)
X, Y = np.meshgrid(x_grid, y_grid)
Z = banana_function(X, Y)
from matplotlib.colors import LogNorm
contour = ax.contourf(X, Y, Z, levels=50, cmap='viridis', norm=LogNorm())
plt.colorbar(contour, label='Cost')

scatter = ax.scatter([], [], c='red', s=30, label='Particles')
leader = ax.scatter([], [], c='white', marker='*', s=200, label='Global Best')
ax.set_title(f"{FUNCTION_NAME} Optimization")
ax.legend()

def animate(frame):
    positions = history_pos[frame]
    scatter.set_offsets(positions)
    # We approximate leader position for visual simplicity in animation
    # (To be perfectly exact we'd need to track gbest history too)
    return scatter,

anim = FuncAnimation(fig, animate, frames=ITERATIONS, interval=100, blit=True)
anim.save('banana_pso.mp4', writer='ffmpeg', fps=15)
print("Saved 'banana_pso.mp4'")
print("Simulation Complete!")
print(f"Your Swarm Found: x={gbest_x:.4f}, y={gbest_y:.4f}")

